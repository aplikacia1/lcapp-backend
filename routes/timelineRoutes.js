// routes/timelineRoutes.js
const express = require('express');
const router = express.Router();
const multer = require('multer');
const fs = require('fs');
const path = require('path');

const TimelinePost = require('../models/timelinePost');
const User = require('../models/User');

/* ===== helpery ===== */
function safeName(original = '') {
  const base = String(original).replace(/[^a-z0-9.\-_]/gi, '_').toLowerCase();
  return `${Date.now()}-${Math.round(Math.random() * 1e9)}-${base}`;
}
function unlinkIfExistsByUrl(app, relUrl) {
  if (!relUrl || !/^\/uploads\//.test(relUrl)) return;
  const base = path.basename(relUrl);
  const full = path.join(app.get('UPLOADS_DIR'), base);
  fs.unlink(full, () => {});
}

/* ===== Multer storage ‚Äì PERSISTENT DISK cez app.get('UPLOADS_DIR') ===== */
const storage = multer.diskStorage({
  destination: (req, _file, cb) => {
    const dir = req.app.get('UPLOADS_DIR');
    try { fs.mkdirSync(dir, { recursive: true }); } catch {}
    cb(null, dir);
  },
  filename: (_req, file, cb) => cb(null, safeName(file.originalname))
});

// limit + filter (z tvojho k√≥du)
const upload = multer({
  storage,
  limits: { fileSize: 7 * 1024 * 1024 }, // max 7 MB
  fileFilter: (_req, file, cb) => {
    const okTypes = [
      'image/jpeg', 'image/png', 'image/webp',
      'image/gif', 'image/heic', 'image/heif'
    ];
    cb(okTypes.includes(file.mimetype) ? null : new Error('Nepodporovan√Ω typ s√∫boru.'), okTypes.includes(file.mimetype));
  }
});

/* ===== Vulgarizmy ‚Äì zachovan√© ===== */
const bannedWords = ['idiot','debil','sprost√Ω','hl√∫py','nad√°vka','kokot','kkt','piƒça','hajzel'];
const containsBannedWords = (t = '') => bannedWords.some(w => String(t).toLowerCase().includes(w));

/* ‚ûï Pridanie pr√≠spevku */
router.post('/add', upload.single('image'), async (req, res) => {
  try {
    const { email, text } = req.body;
    const user = await User.findOne({ email });
    if (!user) return res.status(404).json({ message: 'Pou≈æ√≠vateƒæ nen√°jden√Ω' });
    if (!user.name?.trim()) return res.status(400).json({ message: 'Ch√Ωba prez√Ωvka.' });
    if (!text && !req.file) return res.status(400).json({ message: 'Pr√°zdny pr√≠spevok.' });
    if (containsBannedWords(text)) return res.status(400).json({ message: 'Text obsahuje nevhodn√© slov√°.' });

    const post = new TimelinePost({
      author: user.name,
      text: text || '',
      imageUrl: req.file ? `/uploads/${req.file.filename}` : null,
      createdAt: new Date()
    });

    await post.save();
    res.status(201).json({ message: 'Pr√≠spevok ulo≈æen√Ω' });
  } catch (e) {
    console.error('timeline/add error', e);
    res.status(500).json({ message: 'Chyba servera' });
  }
});

/* üìÑ Z√≠skanie v≈°etk√Ωch pr√≠spevkov */
router.get('/', async (_req, res) => {
  try {
    const posts = await TimelinePost.find().sort({ createdAt: -1 });
    res.status(200).json(posts);
  } catch (e) {
    console.error('timeline list error', e);
    res.status(500).json({ message: 'Chyba pri naƒç√≠tan√≠' });
  }
});

/* üí¨ Pridanie koment√°ra */
router.post('/comment/:postId', async (req, res) => {
  try {
    const { email, text } = req.body;
    const user = await User.findOne({ email });
    if (!user) return res.status(404).json({ message: 'Pou≈æ√≠vateƒæ nen√°jden√Ω' });
    if (!user.name?.trim()) return res.status(400).json({ message: 'Ch√Ωba prez√Ωvka.' });
    if (!text?.trim()) return res.status(400).json({ message: 'Pr√°zdny koment√°r.' });
    if (containsBannedWords(text)) return res.status(400).json({ message: 'Koment√°r obsahuje nevhodn√© slov√°.' });

    const post = await TimelinePost.findById(req.params.postId);
    if (!post) return res.status(404).json({ message: 'Pr√≠spevok nen√°jden√Ω' });

    post.comments.push({ author: user.name, text: text.trim(), createdAt: new Date() });
    await post.save();
    res.status(200).json({ message: 'Koment√°r pridan√Ω' });
  } catch (e) {
    console.error('timeline comment error', e);
    res.status(500).json({ message: 'Chyba servera' });
  }
});

/* üî• Reakcia */
router.post('/react/:postId', async (req, res) => {
  try {
    const { type } = req.body;
    const post = await TimelinePost.findById(req.params.postId);
    if (!post) return res.status(404).json({ message: 'Pr√≠spevok nen√°jden√Ω' });
    if (!['fire','devil','heart'].includes(type)) {
      return res.status(400).json({ message: 'Neplatn√Ω typ reakcie' });
    }
    post.reactions = post.reactions || { fire: 0, devil: 0, heart: 0 };
    post.reactions[type] = (post.reactions[type] || 0) + 1;
    await post.save();
    res.status(200).json({ message: 'Reakcia pridan√°' });
  } catch (e) {
    console.error('timeline react error', e);
    res.status(500).json({ message: 'Chyba servera' });
  }
});

/* üóëÔ∏è Zmaza≈• pr√≠spevok (iba autor) + zmaza≈• s√∫bor z persistent disku */
router.delete('/:postId', async (req, res) => {
  try {
    const email = req.body?.email || req.query?.email;
    if (!email) return res.status(400).json({ message: 'Ch√Ωba email.' });

    const user = await User.findOne({ email });
    if (!user) return res.status(404).json({ message: 'Pou≈æ√≠vateƒæ nen√°jden√Ω' });

    const post = await TimelinePost.findById(req.params.postId);
    if (!post) return res.status(404).json({ message: 'Pr√≠spevok nen√°jden√Ω' });
    if (String(post.author) !== String(user.name)) {
      return res.status(403).json({ message: 'Nem√°te opr√°vnenie.' });
    }

    unlinkIfExistsByUrl(req.app, post.imageUrl);
    await post.deleteOne();
    res.status(200).json({ message: 'Pr√≠spevok zmazan√Ω' });
  } catch (e) {
    console.error('timeline delete error', e);
    res.status(500).json({ message: 'Chyba servera' });
  }
});

/* üóëÔ∏è Zmaza≈• koment√°r (iba autor) */
router.delete('/comment/:postId/:commentId', async (req, res) => {
  try {
    const email = req.body?.email || req.query?.email;
    if (!email) return res.status(400).json({ message: 'Ch√Ωba email.' });
    const user = await User.findOne({ email });
    if (!user) return res.status(404).json({ message: 'Pou≈æ√≠vateƒæ nen√°jden√Ω' });

    const { postId, commentId } = req.params;
    const post = await TimelinePost.findById(postId);
    if (!post) return res.status(404).json({ message: 'Pr√≠spevok nen√°jden√Ω' });

    const idx = Array.isArray(post.comments)
      ? post.comments.findIndex(c => String(c._id) === String(commentId))
      : -1;
    if (idx === -1) return res.status(404).json({ message: 'Koment√°r nen√°jden√Ω' });

    const comment = post.comments[idx];
    if (String(comment.author) !== String(user.name)) {
      return res.status(403).json({ message: 'Nem√°te opr√°vnenie.' });
    }

    post.comments.splice(idx, 1);
    post.markModified('comments');
    await post.save();

    res.status(200).json({ message: 'Koment√°r zmazan√Ω' });
  } catch (e) {
    console.error('timeline comment delete error', e);
    res.status(500).json({ message: 'Chyba servera' });
  }
});

module.exports = router;
